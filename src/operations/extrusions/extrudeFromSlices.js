const { mat4 } = require('../../math')

const { geom2, geom3, poly3 } = require('../../geometry')

const slice = require('./slice')

const extrudeWalls = require('./extrudeWalls')

// NOTE: function definition is required in order to access 'this'
function defaultCallback (t, index) {
  let baseSlice = null
  if (geom2.isA(this)) baseSlice = slice.fromSides(geom2.toSides(this))
  if (poly3.isA(this)) baseSlice = slice.fromPoints(poly3.toPoints(this))

  return t === 0 || t === 1 ? slice.transform(mat4.fromTranslation([0, 0, t]), baseSlice) : null
}

/**
 * Extrude a solid from the slices as returned by the callback function.
 *
 * @param {Object} options - options for extrude
 * @param {Integer} [options.numberOfSlices=2] the number of slices to be generated by the callback
 * @param {Boolean} [options.isCapped=true] the solid should have caps at both start and end
 * @param {Function} [options.callback] the callback function that generates each slice
 * @param {Object} base - the base object which is used to create slices (see below for callback information)
 * @return {geom3} the extruded shape
 *
 * @example
 * let newslice = callback(t, index)
 *     this : the given base object
 *     arguments: t = [0..1], index = [0..numberOfSlices - 1]
 *     return: slice or null (to skip)
 */
const extrudeFromSlices = (options, base) => {
  const defaults = {
    numberOfSlices: 2,
    isCapped: true,
    callback: defaultCallback
  }
  let { numberOfSlices, isCapped, callback } = Object.assign({ }, defaults, options)

  if (numberOfSlices < 2) throw new Error('numberOfSlices must be 2 or more')

  const sMax = numberOfSlices - 1

  let startSlice = null
  let endSlice = null
  let prevSlice = null
  let polygons = []
  for (let s = 0; s < numberOfSlices; s++) {
    // invoke the callback function to get the next slice
    // NOTE: the base object becomes 'this' inside the callback
    // NOTE: callback can return null to skip the slice
    let currentSlice = callback.call(base, s / sMax, s)

    if (currentSlice) {
      if (!slice.isA(currentSlice)) throw new Error('the callback function must return slice objects')

      let edges = slice.toEdges(currentSlice)
      if (edges.length === 0) throw new Error('the callback function must return slices with one or more edges')

      if (prevSlice) {
        polygons = polygons.concat(extrudeWalls(prevSlice, currentSlice))
      }

      // save start and end slices for caps if necessary
      if (s === 0) startSlice = currentSlice
      if (s === (numberOfSlices - 1)) endSlice = currentSlice

      prevSlice = currentSlice
    }
  }

  if (isCapped) {
    // create caps at both ends (closed volume)
    const endPolygons = slice.toPolygons(endSlice)
    polygons = polygons.concat(endPolygons)

    slice.reverse(startSlice, startSlice)
    const startPolygons = slice.toPolygons(startSlice)
    polygons = polygons.concat(startPolygons)
  } else {
    // create walls between end and start slices
    if (!slice.equals(endSlice, startSlice)) {
      polygons = polygons.concat(extrudeWalls(endSlice, startSlice))
    }
  }
  return geom3.create(polygons)
}

module.exports = extrudeFromSlices
