const {mat4, plane, vec3} = require('../../math')

const {geom3, poly3} = require('../../geometry')

const fnSortByIndex = (a, b) => {
  return a.index - b.index
}

const defaultSlice = poly3.fromPoints([ [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0] ])
const defaultCallback = (t, slice) => {
  return t === 0 || t === 1 ? poly3.transform(mat4.fromTranslation([0, 0, t]), defaultSlice) : null
}

/**
 * Extrude a solid from the slices as returned by the callback function.
 * @param {Object} options - options for extrude
 * @param {Integer} [options.numslices=2] the number of slices to be generated by the callback
 * @param {Boolean} [options.loop=false] the slices form a loop of walls (if false then caps are generated)
 * @param {Function} [options.callback] the callback function that generates each slice (poly3)
 * @param {poly3} polygon - the original slice to extrude (passed as 'this' to the callback)
 * @return {geom3} the extruded shape

 * - callback(t, slice)
 *     arguments: t = [0..1], slice = [0..numslices - 1]
 *     return: poly3 or null to skip
 */
const extrudeFromSlices = (options, polygon) => {
  const defaults = {
    numslices: 2,
    loop: false,
    callback: defaultCallback
  }
  let {numslices, loop, callback} = Object.assign({}, defaults, options)

  let bottom = null
  let top = null

  let polygons = []
  let current = null
  let previous = null
  let flipped = null

  for (let i = 0, iMax = numslices - 1; i <= iMax; i++) {
    // get the next slice
    // NOTE: callback can return null to skip the slice
    // NOTE: the original polygon becomes 'this' inside the callback
    current = callback.call(polygon, i / iMax, i)
    if (current) {
      if (!poly3.isA(current)) {
        throw new Error('callback function must return a valid polygon (poly3)')
      }
      //current.checkIfConvex()

      if (previous) {
        // generate walls
        if (flipped === null) { // not generated yet
          flipped = plane.signedDistanceToPoint(previous.plane, poly3.toPoints(current)[0]) < 0
        }
        _addWalls(polygons, previous, current, flipped)
      } else {
        // save the first slice as the bottom
        bottom = current
      }
      previous = current
    }
  }
  // save the last slice as the top
  top = current

  if (loop) {
    // close the loop if necessary
    let bpoints = poly3.toPoints(bottom)
    let tpoints = poly3.toPoints(top)
    let bSameTopBottom = bpoints.length === tpoints.length &&
                  bpoints.every((v, index) => {
                    return vec3.equals(bpoints[index], tpoints[index])
                  })
    // if top and bottom are not the same then generate walls between them
    if (!bSameTopBottom) {
      _addWalls(polygons, top, bottom, flipped)
    }
  } else {
    // use the saved bottom and top as caps
    polygons.unshift(flipped ? bottom : poly3.flip(bottom))
    polygons.push(flipped ? poly3.flip(top) : top)
  }
  return geom3.create(polygons)
}

/**
 * @param walls Array of wall polygons
 * @param bottom Bottom polygon
 * @param top Top polygon
 */
const _addWalls = (walls, bottom, top, bFlipped) => {
  let bottomPoints = poly3.toPoints(bottom).slice(0) // make a shallow copy
  let topPoints = poly3.toPoints(top).slice(0) // make a shallow copy

  // close both set of points, allowing easy wall creation
  if (!vec3.equals(bottomPoints[0], bottomPoints[bottomPoints.length - 1])) {
    bottomPoints.push(bottomPoints[0])
  }
  if (!vec3.equals(topPoints[0], topPoints[topPoints.length - 1])) {
    topPoints.push(topPoints[0])
  }

  if (bFlipped) {
    bottomPoints = bottomPoints.reverse()
    topPoints = topPoints.reverse()
  }

  let iTopLen = topPoints.length - 1
  let iBotLen = bottomPoints.length - 1
  let iExtra = iTopLen - iBotLen // how many extra triangles we need
  let bMoreTops = iExtra > 0
  let bMoreBottoms = iExtra < 0

  // indexes to start extra triangles (polygon with minimal square)
  // exactly iExtra small triangles
  let aMin = []
  for (let i = Math.abs(iExtra); i > 0; i--) {
    aMin.push({
      len: Infinity,
      index: -1
    })
  }

  let len
  if (bMoreBottoms) {
    for (let i = 0; i < iBotLen; i++) {
      len = vec3.squaredDistance(bottomPoints[i], bottomPoints[i + 1])
      // find the element to replace
      for (let j = aMin.length - 1; j >= 0; j--) {
        if (aMin[j].len > len) {
          aMin[j].len = len
          aMin.index = j
          break
        }
      } // for
    }
  } else if (bMoreTops) {
    for (let i = 0; i < iTopLen; i++) {
      len = vec3.squaredDistance(topPoints[i], topPoints[i + 1])
      // find the element to replace
      for (let j = aMin.length - 1; j >= 0; j--) {
        if (aMin[j].len > len) {
          aMin[j].len = len
          aMin.index = j
          break
        }
      } // for
    }
  } // if

  // sort by index
  aMin.sort(fnSortByIndex)

  let getTriangle = (vertexA, vertexB, vertexC) => {
    return poly3.fromPoints([vertexA, vertexB, vertexC])
  }

  let bpoint = bottomPoints[0]
  let tpoint = topPoints[0]
  let secondPoint
  let nBotFacet
  let nTopFacet // length of triangle facet side
  for (let iB = 0, iT = 0, iMax = iTopLen + iBotLen; iB + iT < iMax;) {
    if (aMin.length) {
      if (bMoreTops && iT === aMin[0].index) { // one vertex is on the bottom, 2 - on the top
        secondPoint = topPoints[++iT]
        walls.push(getTriangle(secondPoint, tpoint, bpoint))
        tpoint = secondPoint
        aMin.shift()
        continue
      } else if (bMoreBottoms && iB === aMin[0].index) {
        secondPoint = bottomPoints[++iB]
        walls.push(getTriangle(tpoint, bpoint, secondPoint))
        bpoint = secondPoint
        aMin.shift()
        continue
      }
    }
    // choose the shortest path
    if (iB < iBotLen) { // one vertex is on the top, 2 - on the bottom
      nBotFacet = vec3.squaredDistance(tpoint, bottomPoints[iB + 1])
    } else {
      nBotFacet = Infinity
    }
    if (iT < iTopLen) { // one vertex is on the bottom, 2 - on the top
      nTopFacet = vec3.squaredDistance(bpoint, topPoints[iT + 1])
    } else {
      nTopFacet = Infinity
    }
    if (nBotFacet <= nTopFacet) {
      secondPoint = bottomPoints[++iB]
      walls.push(getTriangle(tpoint, bpoint, secondPoint))
      bpoint = secondPoint
    } else if (iT < iTopLen) { // nTopFacet < Infinity
      secondPoint = topPoints[++iT]
      walls.push(getTriangle(secondPoint, tpoint, bpoint))
      tpoint = secondPoint
    }
  }
  return walls
}

module.exports = extrudeFromSlices
