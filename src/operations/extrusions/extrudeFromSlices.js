'use strict';

const {mat4, vec3} = require('../../math')

const {geom2, geom3, poly3} = require('../../geometry')

const slice = require('./slice')

const extrudeWalls = require('./extrudeWalls')

const fnSortByIndex = (a, b) => {
  return a.index - b.index
}

function defaultCallback(t, index) {
  let baseSlice = null
  if (geom2.isA(this)) baseSlice = slice.fromSides(geom2.toSides(this))
  if (poly3.isA(this)) baseSlice = slice.fromPoints(poly3.toPoints(this))

  return t === 0 || t === 1 ? slice.transform(mat4.fromTranslation([0, 0, t]), baseSlice) : null
}

/**
 * Extrude a solid from the slices as returned by the callback function.
 *
 * @param {Object} options - options for extrude
 * @param {Integer} [options.numslices=2] the number of slices to be generated by the callback
 * @param {Boolean} [options.isCapped=true] the solid should have caps at both start and end
 * @param {Function} [options.callback] the callback function that generates each slice (poly3)
 * @param {Object} base - the base object which is used to create slices (see below for callback information)
 * @return {geom3} the extruded shape
 *
 * @example
 * let newslice = callback(t, index)
 *     this : the given base object
 *     arguments: t = [0..1], index = [0..numslices - 1]
 *     return: slice or null (to skip)
 */
const extrudeFromSlices = (options, base) => {
  const defaults = {
    numslices: 2,
    isCapped: true,
    callback: defaultCallback
  }
  let {numslices, isCapped, callback} = Object.assign({}, defaults, options)

  if (numslices < 2) throw new Error('numslices must be 2 or more')

  const sMax = numslices - 1

  let startSlice = null
  let endSlice = null
  let prevSlice = null
  let polygons = []
  for (let s = 0; s < numslices; s++) {
    // invoke the callback function to get the next slice
    // NOTE: the base object becomes 'this' inside the callback
    // NOTE: callback can return null to skip the slice
    let currentSlice = callback.call(base, s / sMax, s)

    if (currentSlice) {
      if (!slice.isA(currentSlice)) throw new Error('the given callback function must return slice objects')

      if (prevSlice) {
        polygons = polygons.concat(extrudeWalls(prevSlice, currentSlice))
      }

      // save start and end slices for caps if necessary
      if (s === 0) startSlice = currentSlice
      if (s === (numslices - 1)) endSlice = currentSlice

      prevSlice = currentSlice
    }
  }

  if (isCapped) {
    // create caps at both ends (closed volume)
    const endPolygons = slice.toPolygons(endSlice)
    polygons = polygons.concat(endPolygons)

    slice.reverse(startSlice, startSlice)
    const startPolygons = slice.toPolygons(startSlice)
    polygons = polygons.concat(startPolygons)
  } else {
    // create walls between end and start slices
    if (!slice.equals(endSlice, startSlice)) {
      polygons = polygons.concat(extrudeWalls(endSlice, startSlice))
    }
  }
  return geom3.create(polygons)
}

/**
 * @param walls Array of wall polygons
 * @param bottom Bottom polygon
 * @param top Top polygon
 */
const _addWalls = (walls, bottom, top, bFlipped) => {
  let bottomPoints = poly3.toPoints(bottom).slice(0) // make a shallow copy
  let topPoints = poly3.toPoints(top).slice(0) // make a shallow copy

  // close both set of points, allowing easy wall creation
  if (!vec3.equals(bottomPoints[0], bottomPoints[bottomPoints.length - 1])) {
    bottomPoints.push(bottomPoints[0])
  }
  if (!vec3.equals(topPoints[0], topPoints[topPoints.length - 1])) {
    topPoints.push(topPoints[0])
  }

  if (bFlipped) {
    bottomPoints = bottomPoints.reverse()
    topPoints = topPoints.reverse()
  }

  let iTopLen = topPoints.length - 1
  let iBotLen = bottomPoints.length - 1
  let iExtra = iTopLen - iBotLen // how many extra triangles we need
  let bMoreTops = iExtra > 0
  let bMoreBottoms = iExtra < 0

  // indexes to start extra triangles (polygon with minimal square)
  // exactly iExtra small triangles
  let aMin = []
  for (let i = Math.abs(iExtra); i > 0; i--) {
    aMin.push({
      len: Infinity,
      index: -1
    })
  }

  let len
  if (bMoreBottoms) {
    for (let i = 0; i < iBotLen; i++) {
      len = vec3.squaredDistance(bottomPoints[i], bottomPoints[i + 1])
      // find the element to replace
      for (let j = aMin.length - 1; j >= 0; j--) {
        if (aMin[j].len > len) {
          aMin[j].len = len
          aMin.index = j
          break
        }
      } // for
    }
  } else if (bMoreTops) {
    for (let i = 0; i < iTopLen; i++) {
      len = vec3.squaredDistance(topPoints[i], topPoints[i + 1])
      // find the element to replace
      for (let j = aMin.length - 1; j >= 0; j--) {
        if (aMin[j].len > len) {
          aMin[j].len = len
          aMin.index = j
          break
        }
      } // for
    }
  } // if

  // sort by index
  aMin.sort(fnSortByIndex)

  let getTriangle = (vertexA, vertexB, vertexC) => {
    return poly3.fromPoints([vertexA, vertexB, vertexC])
  }

  let bpoint = bottomPoints[0]
  let tpoint = topPoints[0]
  let secondPoint
  let nBotFacet
  let nTopFacet // length of triangle facet side
  for (let iB = 0, iT = 0, iMax = iTopLen + iBotLen; iB + iT < iMax;) {
    if (aMin.length) {
      if (bMoreTops && iT === aMin[0].index) { // one vertex is on the bottom, 2 - on the top
        secondPoint = topPoints[++iT]
        walls.push(getTriangle(secondPoint, tpoint, bpoint))
        tpoint = secondPoint
        aMin.shift()
        continue
      } else if (bMoreBottoms && iB === aMin[0].index) {
        secondPoint = bottomPoints[++iB]
        walls.push(getTriangle(tpoint, bpoint, secondPoint))
        bpoint = secondPoint
        aMin.shift()
        continue
      }
    }
    // choose the shortest path
    if (iB < iBotLen) { // one vertex is on the top, 2 - on the bottom
      nBotFacet = vec3.squaredDistance(tpoint, bottomPoints[iB + 1])
    } else {
      nBotFacet = Infinity
    }
    if (iT < iTopLen) { // one vertex is on the bottom, 2 - on the top
      nTopFacet = vec3.squaredDistance(bpoint, topPoints[iT + 1])
    } else {
      nTopFacet = Infinity
    }
    if (nBotFacet <= nTopFacet) {
      secondPoint = bottomPoints[++iB]
      walls.push(getTriangle(tpoint, bpoint, secondPoint))
      bpoint = secondPoint
    } else if (iT < iTopLen) { // nTopFacet < Infinity
      secondPoint = topPoints[++iT]
      walls.push(getTriangle(secondPoint, tpoint, bpoint))
      tpoint = secondPoint
    }
  }
  return walls
}

module.exports = extrudeFromSlices
